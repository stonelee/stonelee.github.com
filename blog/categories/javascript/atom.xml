<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Stonelee's Blog]]></title>
  <link href="http://stonelee.info/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://stonelee.info/"/>
  <updated>2012-09-19T14:12:27+08:00</updated>
  <id>http://stonelee.info/</id>
  <author>
    <name><![CDATA[stonelee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[当前端遇到Adblock Plus]]></title>
    <link href="http://stonelee.info/blog/2012/09/19/adblock-plus-bug/"/>
    <updated>2012-09-19T00:00:00+08:00</updated>
    <id>http://stonelee.info/blog/2012/09/19/adblock-plus-bug</id>
    <content type="html"><![CDATA[<p>今天将最近开发的演示程序集成到同事的业务框架中去，结果在同事的浏览器中报错：</p>

<p><img src="/images/blog/adblock-bug.png" alt="" /></p>

<p>Firebug中显示报错，但是没有具体错误提示，只显示问题所在代码</p>

<p><code>
r.open('GET', url, true)
</code></p>

<p>点进去看发现其上下文只是一般的ajax调用而已，why？</p>

<h2>排错</h2>

<h3>浏览器问题？</h3>

<p>最初怀疑跟浏览器有关,我测试使用的是chrome和firefox14，而同事使用firefox15.
于是在测试服务器上安装firefox15，木有报错...</p>

<h3>调用库代码问题？</h3>

<p>报错的代码属于seajs，google搜索关键字无果，更新到最新版本还是没效果</p>

<h3>冷静思考</h3>

<p>一共有5个tpl模板文件需要加载，此处加载了4个，出问题的为track.tpl.
于是怀疑模板文件是否格式有问题，难道有未闭合的html标签？
反复对照查看发现没有问题...</p>

<p>索性将调用改为其他模板，这下不再报错了，虽然模板渲染还是有问题。</p>

<p>难道是文件编码问题？隐藏字符？还是文件内容有瑕疵？</p>

<p>猛然想到，同事使用firefox多年，而测试服务器是新安装的纯净版，难道是插件造成的问题?</p>

<h2>原因</h2>

<p>Firefox插件Adblock Plus的过滤列表ChinaList+EasyList中
有规则：</p>

<p><code>
|http://*/track.
</code></p>

<p>导致模板文件track.tpl被屏蔽，从而ajax加载该文件失败</p>

<p>因此解决方案是将该文件改名为tracks.tpl</p>

<p>苦逼前端，除了应付各种浏览器兼容问题，尼玛还要应付浏览器插件兼容!!!
摔！！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bootstrap modal源码分析]]></title>
    <link href="http://stonelee.info/blog/2012/08/22/bootstrap-modal/"/>
    <updated>2012-08-22T00:00:00+08:00</updated>
    <id>http://stonelee.info/blog/2012/08/22/bootstrap-modal</id>
    <content type="html"><![CDATA[<p>要分析的代码见:
<a href="https://github.com/twitter/bootstrap/blob/master/js/bootstrap-modal.js">bootstrap-modal</a></p>

<h2>整体结构</h2>

<p>用匿名函数将代码整个包裹起来，防止全局变量污染。</p>

<p><code>
!function ($) {}(window.jQuery);
</code></p>

<p>但是传递的参数为window.jQuery，这个在使用seajs封装时有点小问题，为了迁就它，不得已只好将jQuery暴露出来。</p>

<h3>类定义</h3>

<p>提供插件的基本逻辑</p>

<p>```
//定义对象
var Modal = function (element, options) {}</p>

<p>//在prototype中定义对象方法
Modal.prototype = {</p>

<pre><code>//constructor重新设置原型链，使得Modal.prototype.constructor === Modal，而不是Object
constructor: Modal
</code></pre>

<p>  , show: function () {}
  , hide: function (e) {}
}
```</p>

<h3>jQuery插件定义</h3>

<p>```
$.fn.modal = function (option) {
  //return使得方法可以进行链式调用。
  return this.each(function () {</p>

<pre><code>var $this = $(this)
  , data = $this.data('modal')
  , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' &amp;&amp; option)
//将内部使用对象存放到data('modal')中，可以轻松从外部获取
if (!data) $this.data('modal', (data = new Modal(this, options)))
if (typeof option == 'string') data[option]()
else if (options.show) data.show()
</code></pre>

<p>  })
}</p>

<p>//使得插件默认配置项可以在插件代码外重新设置。
$.fn.modal.defaults = {</p>

<pre><code>backdrop: true
</code></pre>

<p>  , keyboard: true
  , show: true
}</p>

<p>//代码外面可以通过$.fn.modal.Constructor来获得Modal
$.fn.modal.Constructor = Modal
```</p>

<h3>Data-api</h3>

<p>在页面标签中设置data-toggle就可以提供modal调用，为页面编写者提供了最大的便利。</p>

<p>```
$(function () {
  $('body').on('click.modal.data-api', '[data-toggle="modal"]', function ( e ) {</p>

<pre><code>var $this = $(this)
  , href = $this.attr('href')
  , $target = $($this.attr('data-target') || (href &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
  , option = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) &amp;&amp; href }, $target.data(), $this.data())

e.preventDefault()

$target
  .modal(option)
  .one('hide', function () {
    $this.focus()
  })
</code></pre>

<p>  })
})
```</p>

<h2>技术难点</h2>

<p>```
var Modal = function (element, options) {
  this.options = options
  this.$element = $(element)</p>

<pre><code>.delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this))
</code></pre>

<p>  this.options.remote &amp;&amp; this.$element.find('.modal-body').load(this.options.remote)
}
```</p>

<p>上面这段代码中，</p>

<p>this指向的是Modal类的对象，通过new Modal()生成。
this.options和this.$element是该对象的属性。
this.hide存在于Modal的原型链上，作为该对象的方法被调用。</p>

<p>$.proxy(this.hide, this)使得hide中的this指向这个代码中的this，即modal对象。
如果直接在delegate中调用this.hide，会导致hide中的this指向delegate的目标对象，也就是[data-dismiss="modal"]这个页面组件，通常是个按钮。</p>

<h2>结尾</h2>

<p>不得不佩服Twitter员工的水平，代码结构相当优雅清晰，有许多设计细节值得借鉴。</p>

<p>弄清了整体结构和技术难点，其他部分作为实现细节就简单了，对照着代码看下就好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ExtJS 4 mvc架构演化]]></title>
    <link href="http://stonelee.info/blog/2012/04/26/new-extjs-mvc/"/>
    <updated>2012-04-26T00:00:00+08:00</updated>
    <id>http://stonelee.info/blog/2012/04/26/new-extjs-mvc</id>
    <content type="html"><![CDATA[<p>从年前技术选型开始算起，使用Extjs 4已经四五个月时间了。对比之前的3.x版本，Extjs 4给了我们太多的惊喜：全新的mvc架构、强大的class体系、灵活的js加载方式、纯div布局页面。因此，项目组毫不犹豫地选择其作为前端架构进行新项目的开发。</p>

<p>项目初始时，我们一直遵循推荐的MVC架构：在view中配置页面控件，controller中编写业务逻辑。但随着项目的推进，模块代码越来越多，加之由于种种原因开发时间严重缩短，没有时间进行代码评审，controller中的代码灵活性过强，调用页面控件方式相对繁琐等问题逐渐暴露出来，页面基本无法复用，controller一片狼藉。</p>

<h2>第一次重构</h2>

<p>在用户桌面widget开发时，发现新widget与原模块中的view很像，但是在store,pagingtoolbar等方面略有差别，而controller中的逻辑非常杂乱，一个文件包含了整个模块的业务逻辑，维护和复用都相当困难。</p>

<p>重构结果总结如下:</p>

<ul>
<li>将controller中的业务逻辑尽量移到view中，采用js闭包实现逻辑的相对隔离，跨多view的逻辑依然放在controller中，达到维护容易和代码复用的目的。</li>
<li>采用extend的方式简化view开发</li>
<li>操作按钮尽量使用inline方式，便于用户使用，也有利于集成到其他view中。</li>
<li>add和edit两个界面合为一个，简化开发和维护工作量</li>
<li>store.sync后回传的数据可能与grid中的column不符，这时无法享用自动load的好处，因此应该使用model来save。grid同时使用pagingtoolbar时必须用model来save，然后load，否则pagingtoolbar不能更新。</li>
</ul>


<h2>第二次重构</h2>

<p>业务逻辑移到view中，满足了页面间高内聚、低耦合的设计要求，但是view之间相对独立的特点导致了无法实现逻辑代码复用的问题。</p>

<p>经研究，可以使用mixin来实现逻辑的复用。</p>

<p>例如Grid可以拆分为Columns（基本列）,Crud（增删改）,Operate（操作）,filter（筛选）等minin类,这几个类都包含了控件和业务逻辑,可以灵活配置在各个view中。</p>

<p><img src="/images/blog/Extjs-New-MVC.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ExtJS 4打包工具]]></title>
    <link href="http://stonelee.info/blog/2012/02/16/extjs-4-build-tool/"/>
    <updated>2012-02-16T00:00:00+08:00</updated>
    <id>http://stonelee.info/blog/2012/02/16/extjs-4-build-tool</id>
    <content type="html"><![CDATA[<p>ExtJS 4采用新的MVC思路进行开发。 在项目开发阶段这种分散式的代码组织方式是很爽的，但是应用到生产环境中时为了减少服务端压力，需要对js文件进行压缩打包。 为解决这一问题，官方提供了打包工具<a href="http://www.sencha.com/products/jsbuilder">JSBuilder</a>, 使用方法如下：</p>

<p><code>bash
创建jsb文件：$sencha create jsb -a http://localhost/helloext/index.html -p app.jsb3
构建：$sencha build -p app.jsb3 -d .
</code></p>

<p>但在实际使用时发现，不知道是因为水土不服还是我们的项目结构不合sencha的胃口。在构建jsb3文件的时候不是完全找不到任何路径，就是缺少大量项目文件，可以说是相当鸡肋。</p>

<p>不如自己来吧！</p>

<p>经测试发现，只要按照依赖顺序，将所有文件归置到一个文件中，然后压缩，项目即可正常调用。</p>

<p>打包工具已经放到github上:<a href="https://github.com/stonelee/extjs4-build-tool">https://github.com/stonelee/extjs4-build-tool</a></p>

<h2>思路</h2>

<p>将app下的js文件按照model, store, view, controller的顺序来创建jsb3。</p>

<p>如果view中使用requires加载其它view，则按照依赖顺序先行加载。</p>

<p>然后针对项目需求做了点修改，将app.js按Ext.application分成两部分，分别加载到最后生成的文件中。</p>

<h2>技术点</h2>

<ul>
<li>按照依赖加载关系进行排列<a href="https://github.com/stonelee/extjs4-build-tool/blob/master/sort.py">sort.py</a></li>
<li>文本解析<a href="https://github.com/stonelee/extjs4-build-tool/blob/master/parse.py">parse.py</a></li>
</ul>


<h2>使用方法</h2>

<p>本工具仅仅将项目开发中自己创建的位于app文件夹中的model, store, view, controller以及用于项目整合的app.js打包成一个文件。
其它ExtJS或者ux文件还需要自己打包。
将build-tool放到app同级目录下，项目文档结构如下：</p>

<p><code>
|app
|--controller
|--model
|--store
|--view
|build-tool
|all.js
</code></p>

<p>最终生成文件：</p>

<ul>
<li>app.jsb3 压缩文件路径信息</li>
<li>all-debug.js 未压缩的打包文件,供调试使用</li>
<li>all.js 压缩打包文件,生产环境使用</li>
</ul>


<p>ps:</p>

<p>从开始研究Ext打包，形成思路，到最终完成完整的打包工具并应用到项目中一共用了两天时间，其中纯python编码时间也就半天时间，看来经过这半年的js编码之后，我的python还没太手生嘛哈哈。动态语言之间的学习可以互相促进？待验证~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ext Core设计模式]]></title>
    <link href="http://stonelee.info/blog/2012/02/01/ext-core-design-pattern/"/>
    <updated>2012-02-01T00:00:00+08:00</updated>
    <id>http://stonelee.info/blog/2012/02/01/ext-core-design-pattern</id>
    <content type="html"><![CDATA[<p>参考:
<a href="http://docs.sencha.com/core/manual/">http://docs.sencha.com/core/manual/</a></p>

<h2>Singletons 单例模式</h2>

<p>适用于只有static method或者只需要实例化一次的类，例如应用入口类。可以隐藏私有variables和methods</p>

<p>```js
MyApp = function() {</p>

<pre><code>var data; //data is private and can't be accessed from outside.
return {
    init: function() {
        console.log('init');
        //Initialize application here
    },

    getData: function() {
        return data;
    }
};
</code></pre>

<p>} ();
Ext.onReady(MyApp.init, MyApp);
```</p>

<h2>Observable观察者模式</h2>

<p>Ext.util.Observable使用events实现在多个objects之间解耦</p>

<p>事件触发流程：state changes -> fire event -> notified</p>

<p>```js
var MyClass = Ext.extend(Ext.util.Observable, {</p>

<pre><code>constructor: function(config) {
    this.addEvents('datachanged'); //specify the events we're going to fire
},

update: function() {
    this.fireEvent('datachanged', this, arguments.length);
}
</code></pre>

<p>});</p>

<p>// To subscribe to an event
var c = new MyClass();
c.on('datachanged', function(obj, num) {</p>

<pre><code>console.log(num);
</code></pre>

<p>});
c.update(2, 8, 'some'); //3
```</p>

<h2>Composite 组合模式</h2>

<p>将对象组与单一对象作统一处理，方便用户调用</p>

<p>例如使用select取得的Ext.CompositeElement跟Ext.Element具有同样的调用接口</p>

<h2>Flyweight 享元模式</h2>

<p>使用共有的object，避免创建额外对象，减少内存占用，适用于单行原子操作。</p>

<ul>
<li>使用Ext.fly来以享元的方式获取Element,只能一次性使用</li>
<li>Ext.get可以获取Element，然后保存以供未来使用</li>
<li>Ext.getDom获取dom node</li>
</ul>

]]></content>
  </entry>
  
</feed>
